<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3.5. Job manager &mdash; PLAMS documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/boxes.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="PLAMS documentation" href="index.html" />
    <link rel="up" title="3. Components overview" href="components.html" />
    <link rel="next" title="3.6. Public functions" href="functions.html" />
    <link rel="prev" title="3.4. Job runners" href="runners.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="functions.html" title="3.6. Public functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="runners.html" title="3.4. Job runners"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PLAMS documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="components.html" accesskey="U">3. Components overview</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="job-manager">
<h1>3.5. Job manager<a class="headerlink" href="#job-manager" title="Permalink to this headline">¶</a></h1>
<p>Job manager is the &#8220;director&#8221; of PLAMS environment. It keeps track of all jobs you run, manages the main working folder, allocates job folders to jobs and prevents multiple runs of the same job.</p>
<p>Every instance of <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> is tied to a working folder. This folder is created when <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> instance is initialized and all jobs managed by this instance have their job folders in the working folder. You should not change the job manager&#8217;s working folder after it has been created.</p>
<p>When you initialize PLAMS environment with <a class="reference internal" href="functions.html#scm.plams.common.init" title="scm.plams.common.init"><code class="xref py py-func docutils literal"><span class="pre">init()</span></code></a> function, an instance of <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> is created and stored in <code class="docutils literal"><span class="pre">config.jm</span></code>. This instance is tied to PLAMS main working folder (see <a class="reference internal" href="started.html#master-script"><span>Master script</span></a> for details) and used by default every time some interaction with job manager is required. In a normal situation you would never explicitly touch any <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> instance (create it manually, call any of its methods, explore its data etc.). All interactions are handled automatically from <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.run" title="scm.plams.basejob.Job.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> or other methods.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Usually there is no need to use any other job manager than the default one. Splitting work between multiple instances of <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> may lead to some problems (different instances don&#8217;t communicate, so <a class="reference internal" href="#rerun-prevention"><span>Rerun prevention</span></a> does not work properly).</p>
<p>However, it is possible to manually create another instance of <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> (with a different working folder) and use it for part of your jobs (by passing it as <code class="docutils literal"><span class="pre">jobmanager</span></code> keyword argument to <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.run" title="scm.plams.basejob.Job.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>). If you decide to do so, make sure to pass all instances of <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> you manually created to <a class="reference internal" href="functions.html#scm.plams.common.finish" title="scm.plams.common.finish"><code class="xref py py-func docutils literal"><span class="pre">finish()</span></code></a> (as a list).</p>
<p class="last">An example application for that could be running jobs within your script on many different machines (for example via SSH) and having a separate <a class="reference internal" href="#scm.plams.jobmanager.JobManager" title="scm.plams.jobmanager.JobManager"><code class="xref py py-class docutils literal"><span class="pre">JobManager</span></code></a> on each of them.</p>
</div>
<div class="section" id="rerun-prevention">
<span id="id1"></span><h2>3.5.1. Rerun prevention<a class="headerlink" href="#rerun-prevention" title="Permalink to this headline">¶</a></h2>
<p>In some applications regarding running large numbers of automatically generated jobs (especially in subsystem methods) it may occur that two or more jobs are identical. PLAMS has built in mechanism to detect such situations and avoid unnecessary work.</p>
<p>During <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.run" title="scm.plams.basejob.Job.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>, just before the actual job execution, an unique identifier of a job (called <em>hash</em>) is calculated. Job manager stores all hashes of previously run jobs and checks if the hash of the job you are attempting to execute is not yet present. If such a situation is detected, no execution happens and results of the previous job are used. Results from previous job&#8217;s folder can be either copied or linked to the current job&#8217;s folder, based on <code class="docutils literal"><span class="pre">link_files</span></code> key in <strong>previous</strong> job&#8217;s <code class="docutils literal"><span class="pre">settings</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linking is done using so called hard links. Windows machines do not support hard links and hence if you are running PLAMS under Windows results are always copied.</p>
</div>
<p>The crucial part of the whole rerun prevention mechanism is properly working <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.hash" title="scm.plams.basejob.Job.hash"><code class="xref py py-meth docutils literal"><span class="pre">hash()</span></code></a> function. It needs to produce different hashes for different jobs and exactly the same hashes for jobs that do exactly the same work. It is difficult to come up with the scheme that works well for all kind of external binaries, since the technical details about job preparation can differ a lot. Currently implemented method works based on calculating SHA256 hash of input and/or runscript contents. The value of <code class="docutils literal"><span class="pre">hashing</span></code> key in job manager&#8217;s <code class="docutils literal"><span class="pre">settings</span></code> can be one of the following: <code class="docutils literal"><span class="pre">'input'</span></code>, <code class="docutils literal"><span class="pre">'runscript'</span></code>, <code class="docutils literal"><span class="pre">'input+runscript'</span></code> (or <code class="docutils literal"><span class="pre">None</span></code> to disable the rerun prevention).</p>
<p>If you decide to implement your own hashing method, it can be done by overriding <a class="reference internal" href="jobs.html#scm.plams.basejob.SingleJob.hash" title="scm.plams.basejob.SingleJob.hash"><code class="xref py py-meth docutils literal"><span class="pre">hash()</span></code></a>. Make sure that your version of this method supports three basic modes listed above.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It may happen that two jobs with exactly the same input and runscript files correspond to different jobs (for example if they rely on some external file that is supplied using relative path). Pay special attention to that. If you are experiencing problems (PLAMS sees two different jobs as the same one), disable the rerun prevention.</p>
</div>
<p>In the current implementation hashing is disabled for <a class="reference internal" href="jobs.html#scm.plams.basejob.MultiJob" title="scm.plams.basejob.MultiJob"><code class="xref py py-class docutils literal"><span class="pre">MultiJob</span></code></a> instances since they don&#8217;t have inputs and runscripts. Of course single jobs that are children of multijobs are hashed in a normal way, so trying to run exactly the same multijob as the one run before will not trigger rerun prevention on multijob level but rather for every children single job separately.</p>
</div>
<div class="section" id="pickling">
<span id="id2"></span><h2>3.5.2. Pickling<a class="headerlink" href="#pickling" title="Permalink to this headline">¶</a></h2>
<p>The lifespan of all elements that are parts of PLAMS environment is limited to a single script. That means every script you run uses its own independent job manager, working folder or <code class="docutils literal"><span class="pre">config</span></code> settings. These objects are initialized at the beginning of the script with <a class="reference internal" href="functions.html#scm.plams.common.init" title="scm.plams.common.init"><code class="xref py py-func docutils literal"><span class="pre">init()</span></code></a> command and they cease to exist when the script ends. Also all settings adjustments (apart from those done by editing <code class="docutils literal"><span class="pre">plams_defaults.py</span></code>) are local just for one script.</p>
<p>As a consequence of that the job manager you are using in the current script is not aware of any jobs that had been run in past scripts. However, in some cases it would be very useful to be able to import previously run job to the current script and use its results or build new jobs based on it. For that purpose PLAMS offers data preserving mechanism for job objects. Every time execution of a job successfully finishes (see <a class="reference internal" href="jobs.html#job-life-cycle"><span>Running a job</span></a>) the whole job object is saved to a <code class="docutils literal"><span class="pre">.dill</span></code> file using Python mechanism called <a class="reference external" href="http://docs.python.org/2.7/library/pickle.html#module-pickle" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">pickling</span></code></a>. Such a <code class="docutils literal"><span class="pre">.dill</span></code> file can be loaded in future scripts using <a class="reference internal" href="functions.html#scm.plams.common.load" title="scm.plams.common.load"><code class="xref py py-func docutils literal"><span class="pre">load()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">oldjob</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&#39;/home/user/science/plams.12345/myjob/myjob.dill&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation brings back the old <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance in (almost) exactly the same state it was just after its execution finished.</p>
<div class="technical admonition">
<p class="first admonition-title">Technical</p>
<p>Python pickling mechanism follows references in pickled object. That means that if an object you are trying to pickle contains a reference to another object (just like a <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance has a reference to <a class="reference internal" href="results.html#scm.plams.results.Results" title="scm.plams.results.Results"><code class="xref py py-class docutils literal"><span class="pre">Results</span></code></a> instance), this another object is saved too. Thanks to that after unpickling there are no &#8220;empty&#8221; references in your objects.</p>
<p class="last">However, every <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance in PLAMS has a reference to job manager, which in turns has references to all other jobs, so pickling one job would effectively mean pickling almost the whole environment. To avoid that, every <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance needs to be prepared for pickling by removing references to &#8220;global&#8221; objects, as well as some purely local attributes (path to the job folder for example). During loading, all removed data is replaced with &#8220;proper&#8221; values (current job manager, current path to the job folder etc.).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>There is a way of expanding the mechanism explained in the box above. If your <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> object has an attribute containing a reference to some other object you don&#8217;t want to save together with the job, you may add this object&#8217;s name to job&#8217;s <code class="docutils literal"><span class="pre">_dont_pickle</span></code> list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myjob</span><span class="o">.</span><span class="n">something</span> <span class="o">=</span> <span class="n">some_big_and_clumsy_object_you_dont_want_to_pickle</span>
<span class="n">myjob</span><span class="o">.</span><span class="n">_dont_pickle</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;something&#39;</span><span class="p">]</span> <span class="c">#or myjob._dont_pickle.append(&#39;something&#39;)</span>
</pre></div>
</div>
<p>That way big clumsy object will not be stored in the <code class="docutils literal"><span class="pre">.dill</span></code> file. After loading such a <code class="docutils literal"><span class="pre">.dill</span></code> file the value of <code class="docutils literal"><span class="pre">myjob.something</span></code> will simply be <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p class="last"><code class="docutils literal"><span class="pre">_dont_pickle</span></code> is an attribute of each <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance, initialized by the constructor to an empty list. It does not contain names of attributes that are always removed ( like <code class="docutils literal"><span class="pre">jobmanager</span></code>, for example), only additional ones defined by the user (see <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.__getstate__" title="scm.plams.basejob.Job.__getstate__"><code class="xref py py-meth docutils literal"><span class="pre">Job.__getstate__</span></code></a>)</p>
</div>
<p>As mentioned above, saving a job happens at the very end of <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.run" title="scm.plams.basejob.Job.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a>. The decision if a job should be pickled is based on <code class="docutils literal"><span class="pre">pickle</span></code> key in job&#8217;s <code class="docutils literal"><span class="pre">settings</span></code>, so it can be adjusted for each job separately. If you wish not to pickle a particular job just set <code class="docutils literal"><span class="pre">myjob.settings.pickle</span> <span class="pre">=</span> <span class="pre">False</span></code>. Of course global default setting in <code class="docutils literal"><span class="pre">config.job.pickle</span></code> can also be used.</p>
<p>If you modify a job or its corresponding <a class="reference internal" href="results.html#scm.plams.results.Results" title="scm.plams.results.Results"><code class="xref py py-class docutils literal"><span class="pre">Results</span></code></a> instance afterwards, those changes are not going to be reflected in the <code class="docutils literal"><span class="pre">.dill</span></code> file, since it was created before your changes happened. To store such changes you need to repickle the job manually by calling <code class="docutils literal"><span class="pre">myjob.pickle()</span></code> after doing your changes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Not all Python objects can be properly pickled, so you need to be careful of references to external objects your job or its results store.</p>
</div>
<p>A <a class="reference internal" href="results.html#scm.plams.results.Results" title="scm.plams.results.Results"><code class="xref py py-class docutils literal"><span class="pre">Results</span></code></a> instance associated with a job is saved together with it. However, results do not contain all files produced by job execution but only relative paths to them. For that reason the <code class="docutils literal"><span class="pre">.dill</span></code> file is not enough to fully restore the state if you want to process the results. All other files present in job&#8217;s folder are needed so that <a class="reference internal" href="results.html#scm.plams.results.Results" title="scm.plams.results.Results"><code class="xref py py-class docutils literal"><span class="pre">Results</span></code></a> instance can relate to them. So if you want to copy previously executed job to another location make sure to copy <em>the whole</em> job folder (including subdirectories).</p>
<p>A loaded job is <strong>not</strong> registered in the current job manager. That means it does not get its own subfolder in the main working folder, it never gets renamed and no <a class="reference internal" href="results.html#cleaning"><span>Cleaning job folder</span></a> is done on <a class="reference internal" href="functions.html#scm.plams.common.finish" title="scm.plams.common.finish"><code class="xref py py-func docutils literal"><span class="pre">finish()</span></code></a>. However, it is added to hash registry so it is visible to <a class="reference internal" href="#rerun-prevention"><span>Rerun prevention</span></a>.</p>
<p>In case of <a class="reference internal" href="jobs.html#scm.plams.basejob.MultiJob" title="scm.plams.basejob.MultiJob"><code class="xref py py-class docutils literal"><span class="pre">MultiJob</span></code></a> all information about children jobs is stored in parent&#8217;s <code class="docutils literal"><span class="pre">.dill</span></code> file so loading a <a class="reference internal" href="jobs.html#scm.plams.basejob.MultiJob" title="scm.plams.basejob.MultiJob"><code class="xref py py-class docutils literal"><span class="pre">MultiJob</span></code></a> results in loading all its children jobs. Each children job can have its own <code class="docutils literal"><span class="pre">.dill</span></code> file containing information about that particular job only. <code class="docutils literal"><span class="pre">parent</span></code> attribute of a children job is erased, so loading a children job does not result in loading its parent (and all other children).</p>
</div>
<div class="section" id="restarting-crashed-scripts">
<span id="restarting"></span><h2>3.5.3. Restarting crashed scripts<a class="headerlink" href="#restarting-crashed-scripts" title="Permalink to this headline">¶</a></h2>
<p>Pickling and rerun prevention combine nicely to produce a convenient restart mechanism. When a script tries to do something &#8220;illegal&#8221; it gets stopped by the Python interpreter. Usually it is caused by a mistake in the script (a typo, using wrong variable, accessing wrong element of a list etc.). In such case one would like to correct the script and run it again. But some jobs in the &#8220;wrong&#8221; script may had already been run and successfully finished before the crash occurred. It would be a waste of time to run those jobs again in the corrected script if they are meant to produce exactly the same results as previously. The solution is to load all successfully finished jobs from the crashed script at the beginning of the corrected one and let <a class="reference internal" href="#rerun-prevention"><span>Rerun prevention</span></a> do the rest. However, having to go to the previous script&#8217;s working folder and manually get paths to all <code class="docutils literal"><span class="pre">.dill</span></code> files there would be cumbersome. Fortunately, one can use <a class="reference internal" href="functions.html#scm.plams.common.load_all" title="scm.plams.common.load_all"><code class="xref py py-func docutils literal"><span class="pre">load_all()</span></code></a> function that, given the path to the main working folder of finished PLAMS run, loads all <code class="docutils literal"><span class="pre">.dill</span></code> files stored there. So when you edit your crashed script to remove mistakes you can just add one <a class="reference internal" href="functions.html#scm.plams.common.load_all" title="scm.plams.common.load_all"><code class="xref py py-func docutils literal"><span class="pre">load_all()</span></code></a> call at the beginning and when you run your corrected script no unnecessary work will be done.</p>
<p>Another way of restarting a crashed script is by using <code class="docutils literal"><span class="pre">plams_restart</span></code> script. It is an executable script located in <code class="docutils literal"><span class="pre">$ADFBIN</span></code>, similarly to the master script. It can be invoked directly from the command line:</p>
<div class="highlight-python"><div class="highlight"><pre>plams_restart plams.12345
</pre></div>
</div>
<p>An argument passed to <code class="docutils literal"><span class="pre">plams_restart</span></code> should be the path to the main working folder of previously crashed run.</p>
<p>The way the restart script works is very simple. Every time you run something using <a class="reference internal" href="started.html#master-script"><span>Master script</span></a> the input script (created by concatenating all scripts passed to the master script) is saved in the main working folder as an <code class="docutils literal"><span class="pre">.inp</span></code> file. Thanks to that every PLAMS main working folder &#8220;remembers&#8221; the script that led to its creation and all the details can be quickly checked. You should never change the contents of the <code class="docutils literal"><span class="pre">.inp</span></code> file, just for the hygiene of your own data. Besides that, another file with <code class="docutils literal"><span class="pre">.res</span></code> extension is created in the main working folder. This file is the exact copy of the <code class="docutils literal"><span class="pre">.inp</span></code> file, but unlike it, the <code class="docutils literal"><span class="pre">.res</span></code> file is meant to be edited. If your script crashed and you managed to find out why, you can go to <code class="docutils literal"><span class="pre">.res</span></code> file, edit it to work properly and then invoke <code class="docutils literal"><span class="pre">plams_restart</span></code> on the main working folder. The restart script will first load all successful jobs from there and then execute corrected <code class="docutils literal"><span class="pre">.res</span></code> file. The main working folder for the restart run will be named after the main working folder of the crashed run, appended with <code class="docutils literal"><span class="pre">.res1</span></code> suffix. Besides fixed name and location of the main working folder, the restart run is just an ordinary PLAMS run of <code class="docutils literal"><span class="pre">.res</span></code> file, preceded by loading all <code class="docutils literal"><span class="pre">.dill</span></code> files. <code class="docutils literal"><span class="pre">-v</span></code> flags can be used with <code class="docutils literal"><span class="pre">plams_restart</span></code> in exactly the same way as with the master script.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Remember that rerun prevention checks the hash of the job after the <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.prerun" title="scm.plams.basejob.Job.prerun"><code class="xref py py-meth docutils literal"><span class="pre">prerun()</span></code></a> method is executed. So when you attempt to run a job identical to the one previously run (in the same script, or imported from a previous run), its <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.prerun" title="scm.plams.basejob.Job.prerun"><code class="xref py py-meth docutils literal"><span class="pre">prerun()</span></code></a> method is executed anyway, even if the rest of <a class="reference internal" href="jobs.html#job-life-cycle"><span>Running a job</span></a> is skipped.</p>
</div>
</div>
<div class="section" id="api">
<h2>3.5.4. API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="scm.plams.jobmanager.JobManager">
<em class="property">class </em><code class="descname">JobManager</code><span class="sig-paren">(</span><em>settings</em>, <em>path=None</em>, <em>folder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Class responsible for jobs and files management.</p>
<p>Every instance has the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">folder</span></code> &#8211; the working folder name.</li>
<li><code class="docutils literal"><span class="pre">path</span></code> &#8211; the absolute path to the directory with the working folder.</li>
<li><code class="docutils literal"><span class="pre">workdir</span></code> &#8211; the absolute path to the working folder (<code class="docutils literal"><span class="pre">path/folder</span></code>).</li>
<li><code class="docutils literal"><span class="pre">settings</span></code> &#8211; a <a class="reference internal" href="settings.html#scm.plams.settings.Settings" title="scm.plams.settings.Settings"><code class="xref py py-class docutils literal"><span class="pre">Settings</span></code></a> instance for job manager (see below).</li>
<li><code class="docutils literal"><span class="pre">jobs</span></code> &#8211; a list of all jobs managed with this instance (in order of <a class="reference internal" href="jobs.html#scm.plams.basejob.Job.run" title="scm.plams.basejob.Job.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> calls).</li>
<li><code class="docutils literal"><span class="pre">names</span></code> &#8211; a dictionary with names of jobs. For each name an integer value is stored indicating how many jobs with that name have already been run.</li>
<li><code class="docutils literal"><span class="pre">hashes</span></code> &#8211; a dictionary working as a hash-table for jobs.</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">path</span></code> and <code class="docutils literal"><span class="pre">folder</span></code> can be adjusted with constructor arguments <em>path</em> and <em>folder</em>. If not supplied, Python current working directory and string <code class="docutils literal"><span class="pre">plams.</span></code> appended with PID of the current process are used.</p>
<p><code class="docutils literal"><span class="pre">settings</span></code> attribute is directly set to the value of <em>settings</em> argument (unlike in other classes where they are copied) and it should be a <a class="reference internal" href="settings.html#scm.plams.settings.Settings" title="scm.plams.settings.Settings"><code class="xref py py-class docutils literal"><span class="pre">Settings</span></code></a> instance with the following keys:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">hashing</span></code> &#8211; chosen hashing method (see <a class="reference internal" href="#rerun-prevention"><span>Rerun prevention</span></a>).</li>
<li><code class="docutils literal"><span class="pre">counter_len</span></code> &#8211; length of number appended to job name in case of name conflict.</li>
<li><code class="docutils literal"><span class="pre">remove_empty_directories</span></code> &#8211; if <code class="docutils literal"><span class="pre">True</span></code>, all empty subdirectories of the working folder are removed on <a class="reference internal" href="functions.html#scm.plams.common.finish" title="scm.plams.common.finish"><code class="xref py py-func docutils literal"><span class="pre">finish()</span></code></a>.</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="scm.plams.jobmanager.JobManager._check_hash">
<code class="descname">_check_hash</code><span class="sig-paren">(</span><em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager._check_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the hash of <em>job</em> and, if it is not <code class="docutils literal"><span class="pre">None</span></code>, search previously run jobs for the same hash. If such a job is found, return it. Otherwise, return <code class="docutils literal"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="method">
<dt id="scm.plams.jobmanager.JobManager._clean">
<code class="descname">_clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager._clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean all registered jobs according to their <code class="docutils literal"><span class="pre">save</span></code> parameter in their <code class="docutils literal"><span class="pre">settings</span></code>. If <code class="docutils literal"><span class="pre">remove_empty_directories</span></code> is <code class="docutils literal"><span class="pre">True</span></code>,  traverse the working directory and delete all empty subdirectories.</p>
</dd></dl>

<dl class="method">
<dt id="scm.plams.jobmanager.JobManager._register">
<code class="descname">_register</code><span class="sig-paren">(</span><em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager._register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the <em>job</em>. Register job&#8217;s name (rename if needed) and create the job folder.</p>
</dd></dl>

<dl class="method">
<dt id="scm.plams.jobmanager.JobManager._register_name">
<code class="descname">_register_name</code><span class="sig-paren">(</span><em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager._register_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the name of the <em>job</em>.</p>
<p>If a job with the same name was already registered, <em>job</em> is renamed by appending consecutive integers. Number of digits in the appended number is defined by <code class="docutils literal"><span class="pre">counter_len</span></code> value in job manager&#8217;s <code class="docutils literal"><span class="pre">settings</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="scm.plams.jobmanager.JobManager.load_job">
<code class="descname">load_job</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager.load_job" title="Permalink to this definition">¶</a></dt>
<dd><p>Load previously saved job from <em>filename</em>.</p>
<p><em>Filename</em> should be a path to <code class="docutils literal"><span class="pre">.dill</span></code> file in some job folder. A <a class="reference internal" href="jobs.html#scm.plams.basejob.Job" title="scm.plams.basejob.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance stored there is loaded and returned. All attributes of this instance removed before pickling are restored. This includes <code class="docutils literal"><span class="pre">jobmanager</span></code>, <code class="docutils literal"><span class="pre">path</span></code> (absolute path to <em>filename</em> is used), <code class="docutils literal"><span class="pre">default_setting</span></code> (list containing only <code class="docutils literal"><span class="pre">config.job</span></code>) and also <code class="docutils literal"><span class="pre">parent</span></code> in case of children jobs.</p>
<p>See <a class="reference internal" href="#pickling"><span>Pickling</span></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="scm.plams.jobmanager.JobManager.remove_job">
<code class="descname">remove_job</code><span class="sig-paren">(</span><em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#scm.plams.jobmanager.JobManager.remove_job" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <em>job</em> from job manager. Forget its hash.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo"><a href="http://www.scm.com/">
  <img class="logo" src="_static/scm_logo.png" alt="Logo"/>
</a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.5. Job manager</a><ul>
<li><a class="reference internal" href="#rerun-prevention">3.5.1. Rerun prevention</a></li>
<li><a class="reference internal" href="#pickling">3.5.2. Pickling</a></li>
<li><a class="reference internal" href="#restarting-crashed-scripts">3.5.3. Restarting crashed scripts</a></li>
<li><a class="reference internal" href="#api">3.5.4. API</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="runners.html"
                        title="previous chapter">3.4. Job runners</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="functions.html"
                        title="next chapter">3.6. Public functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/jobmanager.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="functions.html" title="3.6. Public functions"
             >next</a> |</li>
        <li class="right" >
          <a href="runners.html" title="3.4. Job runners"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PLAMS documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="components.html" >3. Components overview</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Scientific Computing &amp; Modelling.
    </div>
  </body>
</html>